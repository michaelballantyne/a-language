(require vendor/immutable runtime/runtime)
(provide read main test valid-module-name valid-id-name)

; Need to add:
;   ===
;   string-append
;   not
;   first
;   rest
;   append

;   generic get, has, empty? Or do I want to use list-ref, hash-ref, obj-ref, etc?
;   Would still be interfaces, but more specific.
;   These are variadic, but defined in JS so don't need to add to compiler:
;     has
;     get
;     obj
;     list
;     hash
;     put


;   Best as macros, but I might want to hack into the parser for now:
;     cond
;     defn

;   variadic functions. I like the idea of ... syntax for defn.

;   format

; Maybe kill #lang loading for now and just special case, to make bootstrap simple

; So far I don't *really* need special paren, brace, and bracket syntax.
; I could drop that for now, in the spirit of minimalism. Parsing it is a pain.

(defn (c-pred pred description)
  (fn (input index)
    (if (and (has input index) (pred (get input index)))
      (obj :position (+ index 1) :failure (list))
      (obj :failure (list (obj :expected description :position index))))))

(defn (c to-match)
  (c-pred (fn (ch) (=== ch to-match))
          (format "character ~a" to-match)))

(defn (c-not to-match)
  (c-pred (fn (ch) (not (has to-match ch)))
          (format "not ~a" to-match)))

(defn (c-range lower upper)
  (c-pred (fn (ch) (and (>= ch lower) (<= ch upper)))
          (format "range ~a to ~a" lower upper)))

(def empty (fn (input index) (obj :position index :failure (list))))

(defn (merge-failures l r)
  (cond
    [(empty? l) r]
    [(empty? r) l]
    [(> (get (first r) :position) (get (first l) :position)) r]
    [(> (get (first l) :position) (get (first r) :position)) r]
    [:else (append l r)]))

(defn (merge-failures l r)
  (if (empty? l) r
    (if (empty? r) l
      (if (> (get (first r) :position) (get (first l) :position)) r
        (if (> (get (first l) :position) (get (first r) :position)) l
          (append l r))))))

(defn (seq parsers ...)
  (fn (input index)
    (loop ([parsers parsers]
           [current-index index]
           [results (list)]
           [failures (list)])
      (if current-index
          (block
            (def res ((first parsers) input current-index))
            (recur (rest parsers)
                   (get res :position)
                   (if (get res :result) (cons res results) results)
                   (merge-failures failures (get res :failure))))
          (obj :position current-index
               :result (if (> (size results) 1) results (first results))
               :failure failures)))))

